package cs.zju.stm.match;

import com.github.gumtreediff.matchers.MappingStore;
import com.github.gumtreediff.tree.ITree;
import cs.zju.config.MyConfig;
import cs.zju.framework.match.StmtMatchMaps;
import cs.zju.framework.match.UniversalTreeNode;
import cs.zju.framework.match.UniversalTreeNodeMaps;
import cs.zju.gitops.GitUtils;
import cs.zju.stm.TreeTokensMap;
import cs.zju.stm.TokenRange;
import cs.zju.stm.edit.sequence.MySequenceAlgorithm;
import cs.zju.treeutils.CheckJDTNodeType;
import cs.zju.utils.Pair;

import java.util.*;


/**
 * This class is used to describe the matching generated by an algorithm between src and dst statements, and
 * the base elements of the statements.
 */

public class StmtMatch {
//    public final static double ratioOfIdenticalTokenThreshold = 0.4;
//    public final static int numOfTokenForShorterStmtUsingThreshold = 3;

    private String matchAlgorithm;

    private ITree srcStmt;
    private ITree dstStmt;
    private MappingStore ms;

    private UniversalTreeNode srcUniversalStmt;
    private UniversalTreeNode dstUniversalStmt;
    private UniversalTreeNode srcUniversalParentNode;
    private UniversalTreeNode dstUniversalParentNode;

    // tokens of src and dst stmts
    private List<TokenRange> srcTokens;
    private List<TokenRange> dstTokens;
    private TreeTokensMap srcTreeTokenMap;
    private TreeTokensMap dstTreeTokenMap;
    private TokenRangeTypeMap srcTokenTypeMap;
    private TokenRangeTypeMap dstTokenTypeMap;

    private UniversalTreeNodeMaps srcUniversalNodeMaps;
    private UniversalTreeNodeMaps dstUniversalNodeMaps;

    // all map of token ranges
    private Map<TokenRange, TokenRange> tokenMapSrcToDst;
    private Map<TokenRange, TokenRange> tokenMapDstToSrc;

    // tokens that are mapped from source statement to destination statement
    private Map<TokenRange, TokenRange> tokenMapSrcToDstInSameStmt;
    // tokens that are mapped from destination statement to source statement
    private Map<TokenRange, TokenRange> tokenMapDstToSrcInSameStmt;
    // tokens mapped from source statement to other destination statements
    private Map<TokenRange, UniversalTreeNode> srcTokenDstStmtMap;
    // tokens mapped from other source statements to this destination statement
    private Map<TokenRange, UniversalTreeNode> dstTokenSrcStmtMap;
    // tokens mapped from source statement to destination statement
    private Map<TokenRange, TokenRange> tokenMapSrcToDstSameStmtTypeOrValue;
    private Map<TokenRange, TokenRange> tokenMapDstToSrcSameStmtTypeOrValue;

    private StmtMatch srcReferenceErrorMatch = null;
    private StmtMatch dstReferenceErrorMatch = null;
    private int srcReferenceErrorType = -1;
    private int dstReferenceErrorType = -1;
    private int srcTokenRefErrorType = -1;
    private int dstTokenRefErrorType = -1;

    // metrics
    private int numOfIdenticalTokens = 0;
    private int numOfMatchedTokensInSameStmt = 0;
    private int numOfNonIdenticalAndMappedTokens = 0;
    private double ratioOfIdenticalTokens = 0;
    private double ancestorMatchScore = 0;
    private double parentMatchScore = 0;
    private double orderMatchScore = 0;
    private int lcsTokens = 0;
    private int srcDiffTypeDiffValueTokenMapped = 0;
    private int dstDiffTypeDiffValueTokenMapped = 0;

    private Map<TokenRange, TokenMetrics> srcTokenMetricMap;
    private Map<TokenRange, TokenMetrics> dstTokenMetricMap;

    // blockmetric
    private int blockMatchScore = 0;

    private List<TokenRange> SingleTokensMovedToOtherStmt;
    private List<TokenRange> SingleTokensMovedFromOtherStmt;

    public StmtMatch(ITree srcStmt, ITree dstStmt, MappingStore ms,
                     TreeTokensMap srcTreeTokenMap, TreeTokensMap dstTreeTokenMap,
                     TokenRangeTypeMap srcTokenTypeMap, TokenRangeTypeMap dstTokenTypeMap,
                     UniversalTreeNodeMaps srcUniversalNodeMaps,
                     UniversalTreeNodeMaps dstUniversalNodeMaps, String matchAlgorithm){
        this.srcStmt = srcStmt;
        this.dstStmt = dstStmt;
        this.ms = ms;
        this.srcTreeTokenMap = srcTreeTokenMap;
        this.dstTreeTokenMap = dstTreeTokenMap;
        this.srcTokenTypeMap = srcTokenTypeMap;
        this.dstTokenTypeMap = dstTokenTypeMap;
        this.srcUniversalNodeMaps = srcUniversalNodeMaps;
        this.dstUniversalNodeMaps = dstUniversalNodeMaps;
        this.matchAlgorithm = matchAlgorithm;

        srcTokenMetricMap = new HashMap<>();
        dstTokenMetricMap = new HashMap<>();

        // init all universal tree nodes
        initUniversalNodes();

        // get all tokens of relevant statements
        initStmtTokens();

        // get matching of tokens between source and destination statement
        // get matching of tokens to other statements
        initTokenMap();

        // metrics
        calculateMetrics();
    }

    private void initUniversalNodes(){
        if (srcStmt != null)
            this.srcUniversalStmt = UniversalTreeNode.getUniversalTreeNode(srcStmt);
        else
            this.srcUniversalStmt = UniversalTreeNode.getNullTreeNode();
        if (dstStmt != null)
            this.dstUniversalStmt = UniversalTreeNode.getUniversalTreeNode(dstStmt);
        else
            this.dstUniversalStmt = UniversalTreeNode.getNullTreeNode();
        this.srcUniversalParentNode = srcUniversalNodeMaps.getParentNode(srcStmt);
        this.dstUniversalParentNode = dstUniversalNodeMaps.getParentNode(dstStmt);
    }

    public int getSrcStmtLine(){
        if (srcStmt != null)
            return srcTreeTokenMap.getStartLineOfStmt(srcStmt.getPos());
        return -1;
    }

    public int getDstStmtLine(){
        if (dstStmt != null)
            return dstTreeTokenMap.getStartLineOfStmt(dstStmt.getPos());
        return -1;
    }

    public int getSrcStartPos(){
        if (srcStmt != null)
            return srcStmt.getPos();
        return -1;
    }

    public int getDstStartPos(){
        if (dstStmt != null)
            return dstStmt.getPos();
        return -1;
    }

    public String getStmtType(){
        return srcStmt != null ? srcStmt.getType().name : dstStmt.getType().name;
    }

    public String[] toRecord_V2(int revId, String commitId, String filePath, int isInaccurate, boolean isSrc,
                                int gtMtdInconsistent, int gtIjmInconsistent, int mtdIjmInconsistent){
        int startPos = isSrc ? srcStmt.getPos() : dstStmt.getPos();
        String[] record = {
                Integer.toString(revId),
                commitId, filePath,
                getMatchAlgorithm(),
                Integer.toString(startPos),
                Integer.toString(isSrc? 1 : 0),
                getStmtType(),
                Integer.toString(getSrcStmtLine()),
                Integer.toString(getDstStmtLine()),
                Integer.toString(isInaccurate),
                Integer.toString(gtMtdInconsistent),
                Integer.toString(gtIjmInconsistent),
                Integer.toString(mtdIjmInconsistent)
        };
        return record;
    }

    public String[] toRecord(int revId){
        String[] record = {
                Integer.toString(revId),
                getStmtType(),
                Integer.toString(getSrcStmtLine()),
                Integer.toString(getDstStmtLine()),
                "", ""
        };
        return record;
    }

    private String getBlankStr(int num){
        String ret = " ";
        for (int i = 0; i < num-1; i++)
            ret += " ";
        return ret;
    }

    public Set<TokenRange> getExchangeSrcTokens(){
        if (srcTokens.size() == 0 || dstTokens.size() == 0)
            return new HashSet<>();
        List<Integer> srcIndexOfDstTokens = new ArrayList<>();
        Set<TokenRange> mappedInSameStmtToken = new HashSet<>();
        for (TokenRange token: dstTokens){
            TokenRange srcToken = tokenMapDstToSrc.get(token);
            int index = srcTokens.indexOf(srcToken);
            if (index == -1)
                continue;
            srcIndexOfDstTokens.add(index);
            mappedInSameStmtToken.add(srcToken);
        }

        List<Integer> srcIndexes = new ArrayList<>(srcIndexOfDstTokens);
        Collections.sort(srcIndexes);
        List<int[]> lcs = lcs(srcIndexes, srcIndexOfDstTokens);

        Set<TokenRange> notMovedTokens = new HashSet<>();
        for (int[] indexes: lcs){
            int srcIdx = srcIndexes.get(indexes[0]);
            notMovedTokens.add(srcTokens.get(srcIdx));
        }
        Set<TokenRange> exchangedSrcTokens = new HashSet<>();
        for (TokenRange token: mappedInSameStmtToken){
            if (!notMovedTokens.contains(token))
                exchangedSrcTokens.add(token);
        }
        return exchangedSrcTokens;
    }

    public String toString_V2(boolean isSrc){
        final int equalSymbolPos = 40;
        final int typeNamePos = 80;

        Set<TokenRange> exchangedSrcTokens = getExchangeSrcTokens();

        String ret = "============================================================\n";
        ret += "**Statement Mapping:**\n";
        String stmtStr = UniversalTreeNode.getStmtLocationStr(srcUniversalStmt, srcTreeTokenMap) +
                " => " +
                UniversalTreeNode.getStmtLocationStr(dstUniversalStmt, dstTreeTokenMap);

        if (UniversalTreeNode.getStmtLocationStr(srcUniversalStmt, srcTreeTokenMap) == null){
            stmtStr = "**ADD**\t" + UniversalTreeNode.getStmtLocationStr(dstUniversalStmt, dstTreeTokenMap);
        }
        if (UniversalTreeNode.getStmtLocationStr(dstUniversalStmt, dstTreeTokenMap) == null){
            stmtStr = "**DEL**\t" + UniversalTreeNode.getStmtLocationStr(srcUniversalStmt, srcTreeTokenMap);
        }

        ret += stmtStr;

        ret += "\n\n";

        ret += "**SRC TOKENS:** " + srcTreeTokenMap.getTokensByRanges(srcTokens) + "\n";
        ret += "**TAG TOKENS:** " + dstTreeTokenMap.getTokensByRanges(dstTokens) + "\n\n";

        if (isSrc) {
            ret += "**Mappings for source tokens:**\n";
            for (TokenRange token : srcTokens) {
                TokenRange dstToken = tokenMapSrcToDst.get(token);
                String tokenStr = "";
                if (dstToken == null){
                    tokenStr += "**DEL**";
                }

                if (dstToken != null){
                    String srcTokenStr = srcTreeTokenMap.getTokenByRange(token);
                    String dstTokenStr = dstTreeTokenMap.getTokenByRange(dstToken);
                    ITree tmpStmt1 = srcTreeTokenMap.getStmtOfTokenRange(token);
                    ITree tmpStmt2 = dstTreeTokenMap.getStmtOfTokenRange(dstToken);

                    if (srcStmt != tmpStmt1 || dstStmt != tmpStmt2)
                        tokenStr += "**MOV**";
                    else if (!srcTokenStr.equals(dstTokenStr))
                        tokenStr += "**UPD**";
                }

                if (exchangedSrcTokens.contains(token)) {
                    tokenStr = "**EXC**";
                }

                if (tokenStr.equals("")){
                    tokenStr += "*******";
                }

                tokenStr += "\t(" + token.toPositionString(srcTreeTokenMap) + ") " + token.toString(srcTreeTokenMap);
                if (dstToken != null) {
                    tokenStr += getBlankStr(equalSymbolPos - tokenStr.length());
                    tokenStr += "=> ";
                    tokenStr += "(" + dstToken.toPositionString(dstTreeTokenMap) + ") " + dstToken.toString(dstTreeTokenMap);
                    tokenStr += getBlankStr(typeNamePos - tokenStr.length());
                    tokenStr += " (" + getTokenType(token, true) + " => " + getTokenType(dstToken, false) + ")";
                }
                ret += tokenStr;
                ret += "\n";
            }
        } else {
            ret += "**Mappings for target tokens:**\n";
            for (TokenRange token : dstTokens) {
                TokenRange srcToken = tokenMapDstToSrc.get(token);
                if (srcToken == null) {
                    ret += "**ADD**" + "\t(" + token.toPositionString(dstTreeTokenMap) + ") " +
                            token.toString(dstTreeTokenMap) + "\n";
                } else {
                    String tokenStr = "";
                    String srcTokenStr = srcTreeTokenMap.getTokenByRange(srcToken);
                    String dstTokenStr = dstTreeTokenMap.getTokenByRange(token);
                    ITree tmpStmt1 = srcTreeTokenMap.getStmtOfTokenRange(srcToken);
                    ITree tmpStmt2 = dstTreeTokenMap.getStmtOfTokenRange(token);
                    if (srcStmt != tmpStmt1 || dstStmt != tmpStmt2)
                        tokenStr += "**MOV**";
                    if (tokenStr.equals("") && !srcTokenStr.equals(dstTokenStr))
                        tokenStr += "**UPD**";
                    if (exchangedSrcTokens.contains(srcToken)) {
                        tokenStr = "**EXC**";
                    }
                    if (tokenStr.equals(""))
                        tokenStr += "*******";

                    tokenStr += "\t(" + srcToken.toPositionString(srcTreeTokenMap) + ") " + srcToken.toString(srcTreeTokenMap);
                    tokenStr += getBlankStr(equalSymbolPos - tokenStr.length());
                    tokenStr += " => ";
                    tokenStr += "(" + token.toPositionString(dstTreeTokenMap) + ") " + token.toString(dstTreeTokenMap);
                    tokenStr += getBlankStr(typeNamePos - tokenStr.length()) +
                            "(" + getTokenType(srcToken, true) + " => " + getTokenType(token, false) + ")";
                    ret += tokenStr;
                    ret += "\n";
                }
            }
        }
        ret += "============================================================\n";
        return ret;
    }

    private void initStmtTokens(){
        this.srcTokens = srcTreeTokenMap.getTokenRangesOfNode(srcStmt);
        this.dstTokens = dstTreeTokenMap.getTokenRangesOfNode(dstStmt);
    }

    public String getTokenType(TokenRange tokenRange, boolean isSrc){
        if (isSrc)
            return srcTokenTypeMap.getTokenType(tokenRange);
        else
            return dstTokenTypeMap.getTokenType(tokenRange);
    }

    private void initTokenMap(){
        tokenMapSrcToDstInSameStmt = new HashMap<>();
        tokenMapDstToSrcInSameStmt = new HashMap<>();
        srcTokenDstStmtMap = new HashMap<>();
        dstTokenSrcStmtMap = new HashMap<>();
        tokenMapSrcToDst = new HashMap<>();
        tokenMapDstToSrc = new HashMap<>();
        tokenMapSrcToDstSameStmtTypeOrValue = new HashMap<>();
        tokenMapDstToSrcSameStmtTypeOrValue = new HashMap<>();

        for (TokenRange srcRange: srcTokens){
            TokenRange dstRange = TreeTokensMap.findMappedRange(ms, srcRange, true,
                    srcTreeTokenMap, dstTreeTokenMap);
            tokenMapSrcToDst.put(srcRange, dstRange);

            ITree curDstStmt = dstTreeTokenMap.getStmtOfTokenRange(dstRange);
            if (curDstStmt != null && curDstStmt == dstStmt){
                tokenMapSrcToDstInSameStmt.put(srcRange, dstRange);
                tokenMapDstToSrcInSameStmt.put(dstRange, srcRange);

                String srcValue = srcTreeTokenMap.getTokenByRange(srcRange);
                String dstValue = dstTreeTokenMap.getTokenByRange(dstRange);

                if (srcValue.equals(dstValue)){
                    tokenMapSrcToDstSameStmtTypeOrValue.put(srcRange, dstRange);
                    tokenMapDstToSrcSameStmtTypeOrValue.put(dstRange, srcRange);
                    continue;
                }

                String srcType = getTokenType(srcRange, true);
                String dstType = getTokenType(dstRange, false);
                if (srcType.equals(dstType)){
                    tokenMapSrcToDstSameStmtTypeOrValue.put(srcRange, dstRange);
                    tokenMapDstToSrcSameStmtTypeOrValue.put(dstRange, srcRange);
                }

            } else {
                srcTokenDstStmtMap.put(srcRange, UniversalTreeNode.getUniversalTreeNode(curDstStmt));
            }
        }

        for (TokenRange dstRange: dstTokens){
            TokenRange srcRange = TreeTokensMap.findMappedRange(ms, dstRange, false,
                    srcTreeTokenMap, dstTreeTokenMap);
            tokenMapDstToSrc.put(dstRange, srcRange);

            if (tokenMapDstToSrcInSameStmt.containsKey(dstRange))
                continue;
            ITree curSrcStmt = srcTreeTokenMap.getStmtOfTokenRange(srcRange);
            dstTokenSrcStmtMap.put(dstRange, UniversalTreeNode.getUniversalTreeNode(curSrcStmt));
        }
    }

    public void calculateMetrics(){
        srcTokenMetricMap = new HashMap<>();
        dstTokenMetricMap = new HashMap<>();
        calculateLcsTokenScore();

        for (TokenRange srcRange: srcTokens){
            srcTokenMetricMap.put(srcRange, new TokenMetrics());
            TokenRange dstRange = tokenMapSrcToDst.get(srcRange);
            String srcType = getTokenType(srcRange, true);
            boolean tokenSameValue = false;
            boolean tokenSameType = false;
            if (dstRange != null){
                String dstType = getTokenType(dstRange, false);
                String srcTokenValue = srcTreeTokenMap.getTokenByRange(srcRange);
                String dstTokenValue = dstTreeTokenMap.getTokenByRange(dstRange);
                tokenSameType = srcType.equals(dstType);
                tokenSameValue = srcTokenValue.equals(dstTokenValue);
                srcTokenMetricMap.get(srcRange).setMapped(1);
                if (!tokenSameType && !tokenSameValue)
                    srcDiffTypeDiffValueTokenMapped = 1;
                if (tokenSameType)
                    srcTokenMetricMap.get(srcRange).setSameTypeMapped(1);
                if (tokenSameValue)
                    srcTokenMetricMap.get(srcRange).setSameValueMapped(1);
            }

            TokenRange dstRangeInSameStmt = tokenMapSrcToDstInSameStmt.get(srcRange);
            if (dstRangeInSameStmt == null) {
                numOfNonIdenticalAndMappedTokens ++;
                continue;
            }
            srcTokenMetricMap.get(srcRange).setSameStmtMapped(1);
            if (!tokenSameValue)
                numOfNonIdenticalAndMappedTokens ++;
            if (srcTokenMetricMap.get(srcRange).getSameTypeMapped()) {
//                int lcsLengthWithoutToken = lcsLengthWithoutToken(srcRange, dstRangeInSameStmt);
//                if (lcsTokens > lcsLengthWithoutToken)
                srcTokenMetricMap.get(srcRange).setInLcsTokensMapped(lcsTokens);
                dstTokenMetricMap.put(dstRangeInSameStmt, new TokenMetrics(srcTokenMetricMap.get(srcRange)));
            }

            numOfMatchedTokensInSameStmt++;
            String srcStringValue = srcTreeTokenMap.getTokenByRange(srcRange);
            String dstStringValue = dstTreeTokenMap.getTokenByRange(dstRangeInSameStmt);
            if (srcStringValue.equals(dstStringValue))
                numOfIdenticalTokens ++;
        }

        for (TokenRange dstRange: dstTokens){
            if (!dstTokenMetricMap.containsKey(dstRange))
                dstTokenMetricMap.put(dstRange, new TokenMetrics());
            TokenRange srcRange = tokenMapDstToSrc.get(dstRange);
            String dstType = getTokenType(dstRange, false);
            boolean tokenSameValue = false;
            boolean tokenSameType = false;
            if (srcRange != null) {
                String srcType = getTokenType(srcRange, true);
                String srcTokenValue = srcTreeTokenMap.getTokenByRange(srcRange);
                String dstTokenValue = dstTreeTokenMap.getTokenByRange(dstRange);
                tokenSameValue = srcTokenValue.equals(dstTokenValue);
                tokenSameType = srcType.equals(dstType);
                dstTokenMetricMap.get(dstRange).setMapped(1);
                if (!tokenSameType && !tokenSameValue)
                    dstDiffTypeDiffValueTokenMapped = 1;
                if (tokenSameType)
                    dstTokenMetricMap.get(dstRange).setSameTypeMapped(1);
                if (tokenSameValue)
                    dstTokenMetricMap.get(dstRange).setSameValueMapped(1);
            }

            TokenRange srcRangeInSameStmt = tokenMapDstToSrcInSameStmt.get(dstRange);
            if (srcRangeInSameStmt == null) {
                numOfNonIdenticalAndMappedTokens++;
                continue;
            }

            dstTokenMetricMap.get(dstRange).setSameStmtMapped(1);
            if (!tokenSameValue)
                numOfNonIdenticalAndMappedTokens++;
        }

        double lengthOfStmt = Math.min(srcTokens.size(), dstTokens.size());
        if (lengthOfStmt > 0)
            ratioOfIdenticalTokens = numOfIdenticalTokens / lengthOfStmt;
        else
            ratioOfIdenticalTokens = -1;

//        calMovedToOtherStmtSingleToken();
//        calMovedFromOtherStmtSingleToken();
        calculateParentMatchScore();
//        calBlockMatchScore_V2();
        calculateBlockMatchScore();
//        calculateOrderScore();
    }

    private void calMovedToOtherStmtSingleToken(){
        SingleTokensMovedToOtherStmt = new ArrayList<>();
        TokenRange lastRange = null;
        TokenRange candidateRange = null;
        for (TokenRange srcRange: srcTokens){
            if (!tokenMapSrcToDstInSameStmt.containsKey(srcRange)){
                if (!TreeTokensMap.isNeighborTokensMoved(ms, lastRange, srcRange, true,
                        srcTreeTokenMap, dstTreeTokenMap)) {
                    if (candidateRange != null) {
                        SingleTokensMovedToOtherStmt.add(candidateRange);
                        candidateRange = null;
                    }
                    TokenRange dstRange = TreeTokensMap.findMappedRange(ms, srcRange, true,
                            srcTreeTokenMap, dstTreeTokenMap);
                    if (dstRange != null) {
                        candidateRange = srcRange;
                    }
                } else {
                    candidateRange = null;
                }
            } else {
                if (candidateRange != null)
                    SingleTokensMovedToOtherStmt.add(candidateRange);
                candidateRange = null;
            }
            lastRange = srcRange;
        }
    }

    private void calMovedFromOtherStmtSingleToken(){
        SingleTokensMovedFromOtherStmt = new ArrayList<>();
        TokenRange lastRange = null;
        TokenRange candidateRange = null;
        for (TokenRange dstRange: dstTokens){
            if (!tokenMapDstToSrcInSameStmt.containsKey(dstRange)){
                if (!TreeTokensMap.isNeighborTokensMoved(ms, lastRange, dstRange, false,
                        srcTreeTokenMap, dstTreeTokenMap)) {
                    if (candidateRange != null) {
                        SingleTokensMovedFromOtherStmt.add(candidateRange);
                        candidateRange = null;
                    }
                    TokenRange srcRange = TreeTokensMap.findMappedRange(ms, dstRange, false,
                            srcTreeTokenMap, dstTreeTokenMap);
                    if (srcRange != null) {
                        candidateRange = dstRange;
                    }
                } else {
                    candidateRange = null;
                }
            } else {
                if (candidateRange != null)
                    SingleTokensMovedFromOtherStmt.add(candidateRange);
                candidateRange = null;
            }
            lastRange = dstRange;
        }
    }

    private int lcsLengthWithoutToken(TokenRange srcToken, TokenRange dstToken){
        if (srcStmt == null || dstStmt == null)
            return -1;
        List<Integer> srcIdxesNoThisToken = new ArrayList<>();
        List<Integer> dstIdxesNoThisToken = new ArrayList<>();

        Map<TokenRange, Integer> dstTokenIdxMap = new HashMap<>();
        for (int i = 0; i < dstTokens.size(); i++){
            dstTokenIdxMap.put(dstTokens.get(i), i);
            if (dstTokens.get(i) != dstToken)
                dstIdxesNoThisToken.add(i);
        }

        for (TokenRange token: srcTokens){
            TokenRange mappedToken = tokenMapSrcToDstSameStmtTypeOrValue.get(token);
            if (mappedToken == null)
                continue;
            if (token != srcToken)
                srcIdxesNoThisToken.add(dstTokenIdxMap.get(mappedToken));
        }
        List<int[]> lcsIdx2 = lcs(srcIdxesNoThisToken, dstIdxesNoThisToken);
        return lcsIdx2.size();
    }

    private void calculateLcsTokenScore(){
        if (srcStmt == null || dstStmt == null){
            return;
        }

        Map<TokenRange, Integer> tokenIdxMap = new HashMap<>();
        List<Integer> srcIdxes = new ArrayList<>();
        List<Integer> dstIdxes = new ArrayList<>();
        for (int i = 0; i < dstTokens.size(); i++){
            tokenIdxMap.put(dstTokens.get(i), i);
            dstIdxes.add(i);
        }

        for (TokenRange token: srcTokens){
            TokenRange dstToken = tokenMapSrcToDstSameStmtTypeOrValue.get(token);
            if (dstToken == null)
                continue;

            srcIdxes.add(tokenIdxMap.get(dstToken));
        }

        List<int[]> lcsIdx = lcs(srcIdxes, dstIdxes);
        lcsTokens = lcsIdx.size();
    }

    private void calculateParentMatchScore(){
        if (srcStmt == null || dstStmt == null){
            parentMatchScore = 1;
            return;
        }
        UniversalTreeNode srcParentNode = srcUniversalNodeMaps.getParentNode(srcUniversalStmt);
        UniversalTreeNode dstParentNode = dstUniversalNodeMaps.getParentNode(dstUniversalStmt);
        if (srcParentNode == null || dstParentNode == null){
            parentMatchScore = -1;
            return;
        }
        ITree srcObj = srcUniversalNodeMaps.getITreeObj(srcParentNode);
        ITree dstObj = dstUniversalNodeMaps.getITreeObj(dstParentNode);
        if (ms.getDstForSrc(srcObj) == dstObj){
            parentMatchScore = 1;
        }
    }

    @Deprecated
    private void calculateAncestorMatchScore(){
        if (srcStmt == null || dstStmt == null){
            ancestorMatchScore = 1;
            return;
        }
        List<UniversalTreeNode> srcAncestorNodes = srcUniversalNodeMaps.getAncestorNodes(srcUniversalStmt);
        List<UniversalTreeNode> dstAncestorNodes = dstUniversalNodeMaps.getAncestorNodes(dstUniversalStmt);

        Set<UniversalTreeNode> dstAncestorNodesSet = new HashSet<>(dstAncestorNodes);

        double numOfAllAncestors = srcAncestorNodes.size() + dstAncestorNodes.size();
        int count = 0;
        for (UniversalTreeNode node: srcAncestorNodes){
            ITree srcParentNode = srcUniversalNodeMaps.getITreeObj(node);
            ITree mappedNode = ms.getDstForSrc(srcParentNode);
            if (mappedNode != null){
                UniversalTreeNode mappedUniversalNode = UniversalTreeNode.getUniversalTreeNode(mappedNode);
                if (dstAncestorNodesSet.contains(mappedUniversalNode))
                    count ++;
            }
        }
        ancestorMatchScore = count * 2 / numOfAllAncestors;
    }

    private static List<int[]> lcs(List<Integer> srcNums, List<Integer> dstNums){
        int[][] lengths = new int[srcNums.size() + 1][dstNums.size() + 1];
        for (int i = 0; i < srcNums.size(); i++){
            for (int j = 0; j < dstNums.size(); j++){
                if (srcNums.get(i).equals(dstNums.get(j)))
                    lengths[i+1][j+1] = lengths[i][j] + 1;
                else
                    lengths[i+1][j+1] = Math.max(lengths[i+1][j], lengths[i][j+1]);
            }
        }
        return MySequenceAlgorithm.extractIndexes(lengths, srcNums.size(), dstNums.size());
    }

    private void calculateOrderScore(){
        if (srcStmt == null || dstStmt == null){
            orderMatchScore = 0;
            return;
        }

        if (srcUniversalParentNode == null || dstUniversalParentNode == null){
            orderMatchScore = 0;
            return;
        }

        List<UniversalTreeNode> srcSiblingNodes = srcUniversalNodeMaps.getChildrenStmts(srcUniversalParentNode);
        List<UniversalTreeNode> dstSiblingNodes = dstUniversalNodeMaps.getChildrenStmts(dstUniversalParentNode);

        Map<UniversalTreeNode, Integer> dstSiblingIndexMap = new HashMap<>();
        for (int i = 0; i < dstSiblingNodes.size(); i++){
            dstSiblingIndexMap.put(dstSiblingNodes.get(i), i);
        }

        List<Integer> srcNums = new ArrayList<>();
        List<Integer> srcNoThisStmtNums = new ArrayList<>();
        for (int i = 0; i < srcSiblingNodes.size(); i++){
             UniversalTreeNode srcNode = srcSiblingNodes.get(i);
             ITree srcITree = srcUniversalNodeMaps.getITreeObj(srcNode);
             ITree mappedTree = ms.getDstForSrc(srcITree);
             if (mappedTree != null){
                 UniversalTreeNode mappedNode = UniversalTreeNode.getUniversalTreeNode(mappedTree);
                 if (dstSiblingIndexMap.containsKey(mappedNode)){
                     int dstIdx = dstSiblingIndexMap.get(mappedNode);
                     srcNums.add(dstIdx);
                     if (srcUniversalStmt != srcNode)
                         srcNoThisStmtNums.add(dstIdx);
                 }
             }
        }

        Set<Integer> tmpSrcSet = new HashSet<>(srcNums);
        Set<Integer> tmpSrcSetNoThisStmt = new HashSet<>(srcNoThisStmtNums);
        List<Integer> dstNums = new ArrayList<>();
        List<Integer> dstNoThisStmtNums = new ArrayList<>();
        for (int i = 0; i < dstSiblingNodes.size(); i++){
            if (tmpSrcSet.contains(i))
                dstNums.add(i);
            if (tmpSrcSetNoThisStmt.contains(i))
                dstNoThisStmtNums.add(i);
        }

        List<int[]> lcsIndexes1 = lcs(srcNums, dstNums);
        List<int[]> lcsIndexes2 = lcs(srcNoThisStmtNums, dstNoThisStmtNums);
        if (lcsIndexes1.size() > lcsIndexes2.size())
            orderMatchScore = lcsIndexes1.size();
        else
            orderMatchScore = 0;
    }

    private boolean hasOneChildBlock(ITree t){
        if (t == null)
            return false;
        int i = 0;
        for (ITree node: t.getChildren()){
            if (CheckJDTNodeType.isBlock(node))
                i ++;
            if (i > 1)
                break;
        }
        return i == 1;
    }

    private void calBlockMatchScore_V2(){
        if (srcStmt == null){
            if (dstUniversalParentNode != null){
                ITree dstParentNode = dstUniversalNodeMaps.getITreeObj(dstUniversalParentNode);
                ITree src = ms.getSrcForDst(dstParentNode);
                boolean dstOnlyOne = hasOneChildBlock(dstParentNode);
                boolean srcOnlyOne = hasOneChildBlock(src);
                if (dstOnlyOne && srcOnlyOne){
                    blockMatchScore = 0;
                    return;
                }
            }
        }

        if (dstStmt == null){
            if (srcUniversalParentNode != null){
                ITree srcParentNode = srcUniversalNodeMaps.getITreeObj(srcUniversalParentNode);
                ITree dst = ms.getDstForSrc(srcParentNode);
                boolean srcOnlyOne = hasOneChildBlock(srcParentNode);
                boolean dstOnlyOne = hasOneChildBlock(dst);
                if (srcOnlyOne && dstOnlyOne){
                    blockMatchScore = 0;
                    return;
                }
            }
        }

        calculateBlockMatchScore();
    }

    private void calculateBlockMatchScore(){
        if (srcStmt == null || dstStmt == null) {
            blockMatchScore = -1;
            return;
        }
        if (srcUniversalParentNode == null || dstUniversalParentNode == null) {
            blockMatchScore = -1;
            return;
        }

        if (CheckJDTNodeType.isBlock(srcStmt) && CheckJDTNodeType.isBlock(dstStmt)) {
            ITree srcParentNode = srcUniversalNodeMaps.getITreeObj(srcUniversalParentNode);
            ITree dstParentNode = dstUniversalNodeMaps.getITreeObj(dstUniversalParentNode);
            if (ms.getDstForSrc(srcParentNode) == dstParentNode)
                blockMatchScore = 1;
            else
                blockMatchScore = 0;
        } else {
            blockMatchScore = 0;
        }
    }


    public ITree getSrcStmt() {
        return srcStmt;
    }

    public ITree getDstStmt() {
        return dstStmt;
    }

    public UniversalTreeNode getSrcUniversalStmt() {
        return srcUniversalStmt;
    }

    public UniversalTreeNode getDstUniversalStmt() {
        return dstUniversalStmt;
    }

    public List<TokenRange> getSrcTokens() {
        return srcTokens;
    }

    public List<TokenRange> getDstTokens() {
        return dstTokens;
    }

    public int getNumOfIdenticalTokens() {
        return numOfIdenticalTokens;
    }

    public int getNumOfMatchedTokensInSameStmt() {
        return numOfMatchedTokensInSameStmt;
    }

    public int getNumOfReasonableMappedTokenInStmt(){
        return tokenMapSrcToDstSameStmtTypeOrValue.size();
    }

    public int getNumOfNonIdenticalAndMappedTokens() {
        return numOfNonIdenticalAndMappedTokens;
    }

    public double getRatioOfIdenticalTokens() {
        return ratioOfIdenticalTokens;
    }

    public int getBlockMatchScore() {
        return blockMatchScore;
    }

    public double getAncestorMatchScore() {
        return ancestorMatchScore;
    }

    public double getOrderMatchScore() {
        return orderMatchScore;
    }

    public String getMatchAlgorithm() {
        return matchAlgorithm;
    }

    public Map<TokenRange, TokenRange> getTokenMapSrcToDst() {
        return tokenMapSrcToDst;
    }

    public Map<TokenRange, TokenRange> getTokenMapDstToSrc() {
        return tokenMapDstToSrc;
    }

    public TreeTokensMap getSrcTreeTokenMap() {
        return srcTreeTokenMap;
    }

    public TreeTokensMap getDstTreeTokenMap() {
        return dstTreeTokenMap;
    }

    public int getLcsTokens() {
        return lcsTokens;
    }

    public int getNumberOfShorterStmtTokens(){
        return Math.min(srcTokens.size(), dstTokens.size());
    }

    public boolean isBlock(){
        return CheckJDTNodeType.isBlock(srcStmt) || CheckJDTNodeType.isBlock(dstStmt);
    }

    public void setSrcReferenceErrorMatch(StmtMatch srcReferenceErrorMatch,
                                          int srcErrorType, int srcTokenRefErrorType) {
        if (srcStmt != null) {
            this.srcReferenceErrorMatch = srcReferenceErrorMatch;
            this.srcReferenceErrorType = srcErrorType;
            this.srcTokenRefErrorType = srcTokenRefErrorType;
        }
    }

    public void setDstReferenceErrorMatch(StmtMatch dstReferenceErrorMatch,
                                          int dstErrorType, int dstTokenRefErrorType){
        if (dstStmt != null) {
            this.dstReferenceErrorMatch = dstReferenceErrorMatch;
            this.dstReferenceErrorType = dstErrorType;
            this.dstTokenRefErrorType = dstTokenRefErrorType;
        }
    }

    // src or dst stmt may be impacted by other inaccurate mappings
    public int getReferenceErrorType(){
        if (srcReferenceErrorMatch != null && dstReferenceErrorMatch != null)
            return StmtComparisonType.BOTH_REFERENCE_ERROR;
        if (srcReferenceErrorMatch != null)
            return StmtComparisonType.SRC_REFERENCE_ERROR;
        if (dstReferenceErrorMatch != null)
            return StmtComparisonType.DST_REFERENCE_ERROR;
        return -1;
    }

    // the reference error match
    public StmtMatch getSrcReferenceErrorMatch() {
        return srcReferenceErrorMatch;
    }

    public StmtMatch getDstReferenceErrorMatch() {
        return dstReferenceErrorMatch;
    }

    public int getSrcReferenceErrorType() {
        return srcReferenceErrorType;
    }

    public int getDstReferenceErrorType() {
        return dstReferenceErrorType;
    }

    public int getSrcTokenRefErrorType() {
        return srcTokenRefErrorType;
    }

    public int getDstTokenRefErrorType() {
        return dstTokenRefErrorType;
    }

    /**
     * return match results and metrics of the stmt match
     */
    public String toString(){
        String srcStmtStr = UniversalTreeNode.getStmtLocationStr(srcUniversalStmt, srcTreeTokenMap);
        String dstStmtStr = UniversalTreeNode.getStmtLocationStr(dstUniversalStmt, dstTreeTokenMap);
        String ret = matchAlgorithm.toUpperCase() + ": " + srcStmtStr + " => " + dstStmtStr + "\n\n";
        return ret;
    }

    /**
     * Describe how the two matchings of the program elements are different.
     * @param matchMaps
     * @return
     */
    public StmtMatchDiffDesc calculateStmtMatchDiffDesc(StmtMatchMaps matchMaps){
        StmtMatch srcStmtMatch = matchMaps.getMatchingForStmt(srcStmt, true);
        StmtMatch dstStmtMatch = matchMaps.getMatchingForStmt(dstStmt, false);
        UniversalTreeNode otherDstUniversalStmt = null;
        UniversalTreeNode otherSrcUniversalStmt = null;

        if (srcStmtMatch != null && srcStmtMatch.getDstUniversalStmt() != dstUniversalStmt)
            otherDstUniversalStmt = srcStmtMatch.getDstUniversalStmt();
        if (dstStmtMatch != null && dstStmtMatch.getSrcUniversalStmt() != srcUniversalStmt)
            otherSrcUniversalStmt = dstStmtMatch.getSrcUniversalStmt();

        StmtMatchDiffDesc desc = new StmtMatchDiffDesc(this);
        desc.setCurrentMatchAlgorithm(matchAlgorithm);
        desc.setCompareAlgorithm(matchMaps.getMatchAlgorithm());
        if ((otherDstUniversalStmt != null && otherDstUniversalStmt != dstUniversalStmt)
                || (otherSrcUniversalStmt != null && otherSrcUniversalStmt != srcUniversalStmt)) {
            desc.setType(StmtMatchDiffDesc.DIFF_AT_STMT);
            desc.setOtherSrcStmt(otherSrcUniversalStmt);
            desc.setOtherDstStmt(otherDstUniversalStmt);
        }
        if (srcStmtMatch != null) {
            for (TokenRange token: srcTokens) {
                TokenRange otherToken = srcStmtMatch.getTokenMapSrcToDst().get(token);
                desc.addOtherMatchForSrcToken(token, otherToken);
            }
        }

        if (dstStmtMatch != null){
            for (TokenRange token: dstTokens){
                TokenRange otherToken = dstStmtMatch.getTokenMapDstToSrc().get(token);
                desc.addOtherMatchForDstToken(token, otherToken);
            }
        }
        return desc;
    }

    /**
     * Generate why a matching generated by an algorithm is worse than the other
     * @param currentAgMaps stmt match results of currently used algorithm
     * @param compareAgMaps stmt match results of the algorithm to compare
     * @param stmtMatch currently evaluated stmt match
     * @return error description
     */
    public static StmtMatchErrorDesc calculateStmtMatchErrorDesc(StmtMatchMaps currentAgMaps,
                                                                 StmtMatchMaps compareAgMaps,
                                                                 StmtMatch stmtMatch){
        String currentAlgorithm = currentAgMaps.getMatchAlgorithm();
        String compareAlgorithm = compareAgMaps.getMatchAlgorithm();
        StmtMatchErrorDesc desc = new StmtMatchErrorDesc(stmtMatch);
        desc.setCurrentMatchAlgorithm(currentAlgorithm);
        desc.setCompareAlgorithm(compareAlgorithm);

        StmtMatch sameStmtMatchForCompareAlgorithm = stmtMatch.getSameStmtMatchForCurrentStmt(compareAgMaps);
        if (sameStmtMatchForCompareAlgorithm != null){
            stmtMatch.calculateErrorDescForSameStmt_Version2(desc, sameStmtMatchForCompareAlgorithm, currentAgMaps);
            return desc;
        }

        Pair<StmtMatch, StmtMatch> otherStmtMatchPair = stmtMatch.getStmtMatchesForCurrentStmt(compareAgMaps);
        if (otherStmtMatchPair != null){
            stmtMatch.calculateErrorDescForDifferentStmt(desc, currentAgMaps,
                    otherStmtMatchPair.first, otherStmtMatchPair.second);
            return desc;
        }

        return null;
    }

    private static boolean isNull(UniversalTreeNode stmt){
        return stmt == null || stmt.isNull();
    }


    private boolean checkMappedStmt(StmtMatchErrorDesc desc){
        if (!isBlock() && !isNull(srcUniversalStmt) && !isNull(dstUniversalStmt) &&
                this.ratioOfIdenticalTokens == 0){
            desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_MATCHED_STMT);
            desc.setComparisonTypeForSrcStmt(StmtComparisonType.NOT_ENOUGH_IDENTICAL_TOKEN);
            desc.setComparisonTypeForDstStmt(StmtComparisonType.NOT_ENOUGH_IDENTICAL_TOKEN);
            return true;
        }
        return false;
    }

    private boolean checkBothSourceAndTargetUnmapped(UniversalTreeNode otherSrcStmt,
                                                     UniversalTreeNode otherDstStmt,
                                                     StmtMatch currentMatchForOtherSrcStmt,
                                                     StmtMatch currentMatchForOtherDstStmt){

        if (isNull(srcUniversalStmt) && !isNull(otherSrcStmt)){
            if (isNull(currentMatchForOtherSrcStmt.getDstUniversalStmt())){
                return true;
            }
        }

        if (isNull(dstUniversalStmt) && !isNull(otherDstStmt)){
            if (isNull(currentMatchForOtherDstStmt.getSrcUniversalStmt())){
                return true;
            }
        }
        return false;
    }


    // If two algorithms generate different matching for the statement nodes,
    // we check which algorithm generates the matching that is likely to be inaccurate
    private void calculateErrorDescForDifferentStmt(StmtMatchErrorDesc desc, StmtMatchMaps currentMatchMaps,
                                                    StmtMatch otherStmtMatchForSrcStmt,
                                                    StmtMatch otherStmtMatchForDstStmt) {

        UniversalTreeNode otherSrcStmt = null;
        if (otherStmtMatchForDstStmt != null)
            otherSrcStmt = otherStmtMatchForDstStmt.getSrcUniversalStmt();
        UniversalTreeNode otherDstStmt = null;
        if (otherStmtMatchForSrcStmt != null)
            otherDstStmt = otherStmtMatchForSrcStmt.getDstUniversalStmt();

        StmtMatch currentMatchForOtherSrcStmt = currentMatchMaps.getMatchingForStmt(otherSrcStmt, true);
        StmtMatch currentMatchForOtherDstStmt = currentMatchMaps.getMatchingForStmt(otherDstStmt, false);

        if (isBlock()){
            if (getBlockMatchScore() == 0) {
                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_MATCHED_STMT);
                desc.setComparisonTypeForSrcStmt(StmtComparisonType.BAD_MATCHED_BLOCK);
                desc.setComparisonTypeForDstStmt(StmtComparisonType.BAD_MATCHED_BLOCK);

                if (currentMatchForOtherDstStmt != null && currentMatchForOtherDstStmt.blockMatchScore == 1)
                    desc.setBetterStmt(otherDstStmt, false, currentMatchMaps);
                if (currentMatchForOtherSrcStmt != null && currentMatchForOtherSrcStmt.blockMatchScore == 1)
                    desc.setBetterStmt(otherSrcStmt, true, currentMatchMaps);
                return;
            }
        }

        // only a small identical token mapped may indicate the stmt is unlikely to be matched
//        if (!isBlock() && !isNull(srcUniversalStmt) && !isNull(dstUniversalStmt) &&
//                this.ratioOfIdenticalTokens < ratioOfIdenticalTokenThreshold &&
//                this.getNumberOfShorterStmtTokens() >= numOfTokenForShorterStmtUsingThreshold){
//            boolean condition1 = currentMatchForOtherSrcStmt != null &&
//                    currentMatchForOtherSrcStmt.ratioOfIdenticalTokens < ratioOfIdenticalTokenThreshold &&
//                    currentMatchForOtherSrcStmt.getNumberOfShorterStmtTokens() >= numOfTokenForShorterStmtUsingThreshold;
//            boolean condition2 = currentMatchForOtherSrcStmt == null;
//            if (condition1 || condition2){
//                boolean condition3 = currentMatchForOtherDstStmt != null &&
//                        currentMatchForOtherDstStmt.ratioOfIdenticalTokens < ratioOfIdenticalTokenThreshold &&
//                        currentMatchForOtherDstStmt.getNumberOfShorterStmtTokens() >= numOfTokenForShorterStmtUsingThreshold;
//                boolean condition4 = currentMatchForOtherDstStmt == null;
//                if (condition3 || condition4){
//                    desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_MATCHED_STMT);
//                }
//            }
//        }
        if (checkMappedStmt(desc))
            return;


        if (this.srcDiffTypeDiffValueTokenMapped == 1 ) {
            desc.setContainsSrcTokenBadMatched(true);
        }

        if (this.dstDiffTypeDiffValueTokenMapped == 1)
            desc.setContainsDstTokenBadMatched(true);

        // 如果发现src和dst都没有map，那么必须确认是真map还是假的
        if (checkBothSourceAndTargetUnmapped(otherSrcStmt, otherDstStmt,
                currentMatchForOtherSrcStmt, currentMatchForOtherDstStmt)) {
            if ("".equals(desc.getErrorType())){
                if (this.srcDiffTypeDiffValueTokenMapped == 1) {
                    desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_TOKEN_MATCH);
                    desc.setComparisonTypeForSrcStmt(StmtComparisonType.SRC_CHANGE_TYPE_AND_VALUE);
                }
                if (this.dstDiffTypeDiffValueTokenMapped == 1){
                    desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_TOKEN_MATCH);
                    desc.setComparisonTypeForDstStmt(StmtComparisonType.DST_CHANGE_TYPE_AND_VALUE);
                }
            }
            return;
        }
//        if (isNull(srcUniversalStmt) && !isNull(otherSrcStmt)){
//            if (isNull(currentMatchForOtherSrcStmt.getDstUniversalStmt())){
//                double ratioOfIdenticalToken = otherStmtMatchForDstStmt.getRatioOfIdenticalTokens();
//                int otherSrcStmtTokenNum = otherStmtMatchForDstStmt.srcTokens.size();
//                if (ratioOfIdenticalToken >= ratioOfIdenticalTokenThreshold &&
//                        otherSrcStmtTokenNum > 1 && dstTokens.size() > 1){
//                    desc.setErrorType(StmtMatchErrorDesc.BETTER_STMT_MATCH);
//                    int comparisonType = StmtComparisonType.ENOUGH_TOKEN_UNMATCHED;
//                    desc.setComparisonTypeForDstStmt(comparisonType);
//                    desc.setBetterStmt(otherSrcStmt, true, currentMatchMaps);
//                }
//                return;
//            }
//        }

//        if (isNull(dstUniversalStmt) && !isNull(otherDstStmt)){
//            if (isNull(currentMatchForOtherDstStmt.getSrcUniversalStmt())){
//                double ratioOfIdenticalToken = otherStmtMatchForSrcStmt.getRatioOfIdenticalTokens();
//                int otherDstStmtTokenNum = otherStmtMatchForSrcStmt.dstTokens.size();
//                if (ratioOfIdenticalToken >= ratioOfIdenticalTokenThreshold &&
//                        otherDstStmtTokenNum > 1 && srcTokens.size() > 1){
//                    desc.setErrorType(StmtMatchErrorDesc.BETTER_STMT_MATCH);
//                    int comparisonType = StmtComparisonType.ENOUGH_TOKEN_UNMATCHED;
//                    desc.setComparisonTypeForSrcStmt(comparisonType);
//                    desc.setBetterStmt(otherDstStmt, false, currentMatchMaps);
//                }
//                return;
//            }
//        }

        int comparisonType1 = calculateComparisonTypeForDifferentStmt(this, otherStmtMatchForSrcStmt);
        int comparisonType2 = calculateComparisonTypeForDifferentStmt(currentMatchForOtherDstStmt, otherStmtMatchForSrcStmt);

        if (comparisonType1 > 0 && comparisonType2 > 0 ){
            desc.setErrorType(StmtMatchErrorDesc.BETTER_STMT_MATCH);
            desc.setComparisonTypeForSrcStmt(Math.min(comparisonType1, comparisonType2));
            desc.setBetterStmt(otherDstStmt, false, currentMatchMaps);
        }

        int comparisonType3 = calculateComparisonTypeForDifferentStmt(this, otherStmtMatchForDstStmt);
        int comparisonType4 = calculateComparisonTypeForDifferentStmt(currentMatchForOtherSrcStmt, otherStmtMatchForDstStmt);
        if (comparisonType3 > 0 && comparisonType4 > 0){
            desc.setErrorType(StmtMatchErrorDesc.BETTER_STMT_MATCH);
            desc.setComparisonTypeForDstStmt(Math.min(comparisonType3, comparisonType4));
            desc.setBetterStmt(otherSrcStmt, true, currentMatchMaps);
        }

        if ("".equals(desc.getErrorType())){
            if (this.srcDiffTypeDiffValueTokenMapped == 1) {
                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_TOKEN_MATCH);
                desc.setComparisonTypeForSrcStmt(StmtComparisonType.SRC_CHANGE_TYPE_AND_VALUE);
            }
            if (this.dstDiffTypeDiffValueTokenMapped == 1){
                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_TOKEN_MATCH);
                desc.setComparisonTypeForDstStmt(StmtComparisonType.DST_CHANGE_TYPE_AND_VALUE);
            }
        }
    }

    private Pair<StmtMatch, StmtMatch> getStmtMatchesForCurrentStmt(StmtMatchMaps compareMatchMaps){
        if (srcStmt != null){
            StmtMatch match = compareMatchMaps.getMatchingForStmt(srcStmt, true);
            if (match.getDstUniversalStmt() != dstUniversalStmt){
                StmtMatch match2 = compareMatchMaps.getMatchingForStmt(dstStmt, false);
                return new Pair<>(match, match2);
            }
        } else {
            StmtMatch match2 = compareMatchMaps.getMatchingForStmt(dstStmt, false);
            if (match2.getSrcUniversalStmt() != srcUniversalStmt){
                StmtMatch match = compareMatchMaps.getMatchingForStmt(srcStmt, true);
                return new Pair<>(match, match2);
            }
        }
        return null;
    }

    private StmtMatch getSameStmtMatchForCurrentStmt(StmtMatchMaps compareMatchMaps){
        if (srcStmt != null){
            StmtMatch match = compareMatchMaps.getMatchingForStmt(srcStmt, true);
            if (match.getDstUniversalStmt() == dstUniversalStmt)
                return match;
        } else {
            StmtMatch match = compareMatchMaps.getMatchingForStmt(dstStmt, false);
            if (match.getSrcUniversalStmt() == srcUniversalStmt)
                return match;
        }
        return null;
    }

    private void calculateErrorDescForSameStmt_Version2(StmtMatchErrorDesc desc, StmtMatch compareMatch,
                                                        StmtMatchMaps currentMatchMaps){
        if (isBlock()){
            if (getBlockMatchScore() == 0) {
                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_MATCHED_STMT);
                desc.setComparisonTypeForSrcStmt(StmtComparisonType.BAD_MATCHED_BLOCK);
                desc.setComparisonTypeForDstStmt(StmtComparisonType.BAD_MATCHED_BLOCK);
            }
            return;
        }
        if (checkMappedStmt(desc))
            return;
//        if (!isBlock() && !isNull(srcUniversalStmt) && !isNull(dstUniversalStmt) &&
//                this.ratioOfIdenticalTokens < ratioOfIdenticalTokenThreshold &&
//                this.getNumberOfShorterStmtTokens() >= numOfTokenForShorterStmtUsingThreshold){
//            if (compareMatch.ratioOfIdenticalTokens < ratioOfIdenticalTokenThreshold &&
//                    this.getNumberOfShorterStmtTokens() >= numOfTokenForShorterStmtUsingThreshold){
//                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_MATCHED_STMT);
//            }
//        }

        Map<TokenRange, Integer> srcTokenTypeMap = new HashMap<>();
        Map<TokenRange, Integer> dstTokenTypeMap = new HashMap<>();
        for (TokenRange srcToken: srcTokens){
            int comparisonType = calculateComparisonTypeForToken(this, compareMatch, srcToken, true);
            if (comparisonType > 0) {
                srcTokenTypeMap.put(srcToken, comparisonType);
                desc.setErrorType(StmtMatchErrorDesc.BETTER_TOKEN_MATCH);
            }
        }

        for (TokenRange dstToken: dstTokens){
            int comparisonType = calculateComparisonTypeForToken(this, compareMatch, dstToken, false);
            if (comparisonType > 0) {
                dstTokenTypeMap.put(dstToken, comparisonType);
                desc.setErrorType(StmtMatchErrorDesc.BETTER_TOKEN_MATCH);
            }
        }

        desc.setTokenComparisonTypeMap(srcTokenTypeMap, dstTokenTypeMap,
                srcTreeTokenMap, dstTreeTokenMap, currentMatchMaps);
    }

    @Deprecated
    private void calculateErrorDescForSameStmt(StmtMatchErrorDesc desc, StmtMatch compareMatch,
                                               StmtMatchMaps currentMatchMaps){
        if (isBlock()){
            if (getBlockMatchScore() == 0) {
                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_MATCHED_STMT);
                desc.setComparisonTypeForSrcStmt(StmtComparisonType.BAD_MATCHED_BLOCK);
                desc.setComparisonTypeForDstStmt(StmtComparisonType.BAD_MATCHED_BLOCK);
            }
            return;
        }
//        if (!isBlock() && !isNull(srcUniversalStmt) && !isNull(dstUniversalStmt) &&
//                this.ratioOfIdenticalTokens < ratioOfIdenticalTokenThreshold &&
//                this.getNumberOfShorterStmtTokens() >= numOfTokenForShorterStmtUsingThreshold){
//            if (compareMatch.ratioOfIdenticalTokens < ratioOfIdenticalTokenThreshold &&
//                    this.getNumberOfShorterStmtTokens() >= numOfTokenForShorterStmtUsingThreshold){
//                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_MATCHED_STMT);
//            }
//        }

        if (this.srcDiffTypeDiffValueTokenMapped == 1)
            desc.setContainsSrcTokenBadMatched(true);
        if (this.dstDiffTypeDiffValueTokenMapped == 1)
            desc.setContainsDstTokenBadMatched(true);

        int comparisonType = calculateComparisonTypeForSameStmt(this, compareMatch);
        if (comparisonType == StmtComparisonType.LESS_TOKEN_SAME_STMT) {
            desc.setErrorType(StmtMatchErrorDesc.BETTER_TOKEN_MATCH);
            desc.setComparisonTypeForSameStmt(comparisonType);
            for (TokenRange token : srcTokens){
                if (tokenMapSrcToDstSameStmtTypeOrValue.containsKey(token))
                    continue;
                if (compareMatch.tokenMapSrcToDstSameStmtTypeOrValue.containsKey(token)){
                    TokenRange compareDstToken = compareMatch.tokenMapSrcToDstSameStmtTypeOrValue.get(token);
                    desc.addMoreTokenToMap(token, compareDstToken, true,
                            srcTreeTokenMap, dstTreeTokenMap, currentMatchMaps);
                }
            }

            for (TokenRange token : dstTokens){
                if (tokenMapDstToSrcSameStmtTypeOrValue.containsKey(token))
                    continue;
                if (compareMatch.tokenMapDstToSrcSameStmtTypeOrValue.containsKey(token)){
                    TokenRange compareSrcToken = compareMatch.tokenMapDstToSrcSameStmtTypeOrValue.get(token);
                    desc.addMoreTokenToMap(compareSrcToken, token, false,
                            srcTreeTokenMap, dstTreeTokenMap, currentMatchMaps);
                }
            }
        }

        if (comparisonType == StmtComparisonType.LESS_LCS_TOKEN) {
            desc.setErrorType(StmtMatchErrorDesc.BETTER_TOKEN_MATCH);
            desc.setComparisonTypeForSameStmt(comparisonType);
        }

        if ("".equals(desc.getErrorType())){
            if (this.srcDiffTypeDiffValueTokenMapped == 1){
                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_TOKEN_MATCH);
                desc.setComparisonTypeForSrcStmt(StmtComparisonType.SRC_CHANGE_TYPE_AND_VALUE);
            }
            if (this.dstDiffTypeDiffValueTokenMapped == 1){
                desc.setErrorType(StmtMatchErrorDesc.UNLIKELY_TOKEN_MATCH);
                desc.setComparisonTypeForDstStmt(StmtComparisonType.DST_CHANGE_TYPE_AND_VALUE);
            }
        }
    }

    public TokenMetrics getTokenMetrics(TokenRange token, boolean isSrc){
        if (token == null)
            return null;
        if (isSrc)
            return srcTokenMetricMap.get(token);
        else
            return dstTokenMetricMap.get(token);
    }

    private static int calculateComparisonTypeForToken(StmtMatch sm1, StmtMatch sm2,
                                                       TokenRange token, boolean isSrc){
        if (isSrc) {
            if (TokenRange.isEqualTo(sm1.tokenMapSrcToDst.get(token), sm2.tokenMapSrcToDst.get(token)))
                return 0;
        } else {
            if (TokenRange.isEqualTo(sm1.tokenMapDstToSrc.get(token), sm2.tokenMapDstToSrc.get(token)))
                return 0;
        }
        TokenMetrics metrics1 = sm1.getTokenMetrics(token, isSrc);
        TokenMetrics metrics2 = sm2.getTokenMetrics(token, isSrc);
        int comparisonType1 = TokenMetrics.doCompare(metrics1, metrics2);
        if (comparisonType1 == TokenComparisonType.CHANGE_TOKEN_TYPE_AND_VALUE)
            return comparisonType1;
        TokenRange mappedToken;
        if (isSrc){
            mappedToken = sm2.tokenMapSrcToDst.get(token);
        } else {
            mappedToken = sm2.tokenMapDstToSrc.get(token);
        }
        TokenMetrics metrics3 = sm1.getTokenMetrics(mappedToken, !isSrc);
        if (metrics3 == null)
            return comparisonType1;
        int comparisonType2 = TokenMetrics.doCompare(metrics3, metrics2);
        return Math.min(comparisonType1, comparisonType2);
    }

    private static int calculateComparisonTypeForSameStmt(StmtMatch sm1, StmtMatch sm2){
        if (sm1 == null || sm2 == null)
            return StmtComparisonType.CANNOT_COMPARE;

        // Tokens matched in same statement
        int numOfTokenInStmt_1 = sm1.getNumOfReasonableMappedTokenInStmt();
        int numOfTokenInStmt_2 = sm2.getNumOfReasonableMappedTokenInStmt();
        if (numOfTokenInStmt_1 < numOfTokenInStmt_2)
            return StmtComparisonType.LESS_TOKEN_SAME_STMT;
        if (numOfTokenInStmt_1 > numOfTokenInStmt_2)
            return StmtComparisonType.MORE_TOKEN_SAME_STMT;

        // Lcs tokens
        int numOfLcsToken_1 = sm1.getLcsTokens();
        int numOfLcsToken_2 = sm2.getLcsTokens();
        if (numOfLcsToken_1 < numOfLcsToken_2)
            return StmtComparisonType.LESS_LCS_TOKEN;
        if (numOfLcsToken_1 > numOfLcsToken_2)
            return StmtComparisonType.MORE_LCS_TOKEN;

        return StmtComparisonType.CANNOT_COMPARE;
    }

    private static int calculateComparisonTypeForDifferentStmt(StmtMatch sm1, StmtMatch sm2){
        if (sm1 == null || sm2 == null)
            return StmtComparisonType.CANNOT_COMPARE;

        if (!sm1.isBlock() && !sm2.isBlock()) {
            // Identical token comparison
            int numOfIdenticalToken1 = sm1.getNumOfIdenticalTokens();
            int numOfIdenticalToken2 = sm2.getNumOfIdenticalTokens();
            if (numOfIdenticalToken1 < numOfIdenticalToken2)
                return StmtComparisonType.LESS_IDENTICAL_TOKEN;
            if (numOfIdenticalToken1 > numOfIdenticalToken2)
                return StmtComparisonType.MORE_IDENTICAL_TOKEN;

            // the tokens other than the mapped identical tokens
//            int numOfNonIdenticalAndMappedToken_1 = sm1.numOfNonIdenticalAndMappedTokens;
//            int numOfNonIdenticalAndMappedToken_2 = sm2.numOfNonIdenticalAndMappedTokens;
//            if (numOfNonIdenticalAndMappedToken_1 < numOfNonIdenticalAndMappedToken_2)
//                return StmtComparisonType.LESS_UNMATCHED_TOKEN_IN_STMT;
//            if (numOfNonIdenticalAndMappedToken_1 > numOfNonIdenticalAndMappedToken_2)
//                return StmtComparisonType.MORE_UNMATCHED_TOKEN_IN_STMT;

            // Better ancestor node found
            double ancestorSim_1 = sm1.parentMatchScore;
            double ancestorSim_2 = sm2.parentMatchScore;
            if (ancestorSim_1 < ancestorSim_2)
                return StmtComparisonType.WORSE_ANCESTOR_MATCHED;
            if (ancestorSim_1 > ancestorSim_2)
                return StmtComparisonType.BETTER_ANCESTOR_MATCHED;
        }
        // Better Sibling position
//        double orderSim_1 = sm1.getOrderMatchScore();
//        double orderSim_2 = sm2.getOrderMatchScore();
//        if (orderSim_1 < orderSim_2)
//            return StmtComparisonType.WORSE_ORDER_MATCHED;
//        if (orderSim_1 > orderSim_2)
//            return StmtComparisonType.BETTER_ORDER_MATCHED;

        return StmtComparisonType.CANNOT_COMPARE;
    }

}
